import { r as refreshSession } from "./refreshSession-WwGlzgtM.js";
const attachAccessTokenMiddleware = (storage) => (next) => async (url, options = {}) => {
  const headers = new Headers(options.headers || {});
  if (headers.has("Authorization")) {
    return next(url, options);
  }
  const session = storage.get();
  if (session?.accessToken) {
    const newOptions = {
      ...options,
      headers: addAuthorizationHeader(headers, session)
    };
    return next(url, newOptions);
  }
  return next(url, options);
};
function addAuthorizationHeader(headers, session) {
  if (session.accessToken) {
    headers.set("Authorization", `Bearer ${session.accessToken}`);
  }
  return headers;
}
const sessionRefreshMiddleware = (auth, storage, options) => {
  const { marginSeconds = 60 } = options || {};
  return (next) => async (url, options2 = {}) => {
    if (shouldSkipTokenHandling(url, options2)) {
      return next(url, options2);
    }
    try {
      await refreshSession(auth, storage, marginSeconds);
    } catch {
    }
    return next(url, options2);
  };
};
function shouldSkipTokenHandling(url, options) {
  const headers = new Headers(options.headers || {});
  if (headers.has("Authorization")) {
    return true;
  }
  if (url.endsWith("/v1/token")) {
    return true;
  }
  return false;
}
const updateSessionFromResponseMiddleware = (storage) => {
  const sessionExtractor = (body) => {
    if (typeof body === "string") {
      return null;
    }
    if ("session" in body) {
      return body.session || null;
    }
    if ("accessToken" in body && "refreshToken" in body && "user" in body) {
      return body;
    }
    return null;
  };
  return (next) => async (url, options) => {
    const response = await next(url, options);
    try {
      if (url.endsWith("/signout")) {
        storage.remove();
        return response;
      }
      if (url.endsWith("/token") || url.includes("/signin/") || url.includes("/signup/")) {
        const clonedResponse = response.clone();
        const body = await clonedResponse.json().catch(() => null);
        if (body) {
          const session = sessionExtractor(body);
          if (session?.accessToken && session.refreshToken) {
            storage.set(session);
          }
        }
      }
    } catch (error) {
      console.warn("Error in session response middleware:", error);
    }
    return response;
  };
};
const withAdminSessionMiddleware = (options) => (next) => async (url, requestOptions = {}) => {
  const headers = new Headers(requestOptions.headers || {});
  if (!headers.has("x-hasura-admin-secret")) {
    headers.set("x-hasura-admin-secret", options.adminSecret);
  }
  if (options.role && !headers.has("x-hasura-role")) {
    headers.set("x-hasura-role", options.role);
  }
  if (options.sessionVariables) {
    for (const [key, value] of Object.entries(options.sessionVariables)) {
      const headerKey = key.startsWith("x-hasura-") ? key : `x-hasura-${key}`;
      if (!headers.has(headerKey)) {
        headers.set(headerKey, value);
      }
    }
  }
  return next(url, { ...requestOptions, headers });
};
export {
  attachAccessTokenMiddleware as a,
  sessionRefreshMiddleware as s,
  updateSessionFromResponseMiddleware as u,
  withAdminSessionMiddleware as w
};
//# sourceMappingURL=middlewareWithAdminSession-BeIk-9HO.js.map
