{"version":3,"file":"storage.cjs","sources":["../../src/storage/client.ts"],"sourcesContent":["/**\n * This file is auto-generated. Do not edit manually.\n */\n\nimport type { ChainFunction, FetchResponse } from '../fetch';\nimport { createEnhancedFetch, FetchError } from '../fetch';\n\n/**\n * Date in RFC 2822 format\n */\nexport type RFC2822Date = string;\n\n/**\n * Error details.\n @property message (`string`) - Human-readable error message.\n    *    Example - `\"File not found\"`\n @property data? (`Record<string, unknown>`) - Additional data related to the error, if any.*/\nexport interface ErrorResponseError {\n  /**\n   * Human-readable error message.\n   *    Example - `\"File not found\"`\n   */\n  message: string;\n  /**\n   * Additional data related to the error, if any.\n   */\n  data?: Record<string, unknown>;\n}\n\n/**\n * Error information returned by the API.\n @property error? (`ErrorResponseError`) - Error details.*/\nexport interface ErrorResponse {\n  /**\n   * Error details.\n   */\n  error?: ErrorResponseError;\n}\n\n/**\n * Error details.\n @property message (`string`) - Human-readable error message.\n    *    Example - `\"File not found\"`\n @property data? (`Record<string, unknown>`) - Additional data related to the error, if any.*/\nexport interface ErrorResponseWithProcessedFilesError {\n  /**\n   * Human-readable error message.\n   *    Example - `\"File not found\"`\n   */\n  message: string;\n  /**\n   * Additional data related to the error, if any.\n   */\n  data?: Record<string, unknown>;\n}\n\n/**\n * Error information returned by the API.\n @property processedFiles? (`FileMetadata[]`) - List of files that were successfully processed before the error occurred.\n @property error? (`ErrorResponseWithProcessedFilesError`) - Error details.*/\nexport interface ErrorResponseWithProcessedFiles {\n  /**\n   * List of files that were successfully processed before the error occurred.\n   */\n  processedFiles?: FileMetadata[];\n  /**\n   * Error details.\n   */\n  error?: ErrorResponseWithProcessedFilesError;\n}\n\n/**\n * Comprehensive metadata information about a file in storage.\n @property id (`string`) - Unique identifier for the file.\n    *    Example - `\"d5e76ceb-77a2-4153-b7da-1f7c115b2ff2\"`\n @property name (`string`) - Name of the file including extension.\n    *    Example - `\"profile-picture.jpg\"`\n @property size (`number`) - Size of the file in bytes.\n    *    Example - `245678`\n    *    Format - int64\n @property bucketId (`string`) - ID of the bucket containing the file.\n    *    Example - `\"users-bucket\"`\n @property etag (`string`) - Entity tag for cache validation.\n    *    Example - `\"\\\"a1b2c3d4e5f6\\\"\"`\n @property createdAt (`string`) - Timestamp when the file was created.\n    *    Example - `\"2023-01-15T12:34:56Z\"`\n    *    Format - date-time\n @property updatedAt (`string`) - Timestamp when the file was last updated.\n    *    Example - `\"2023-01-16T09:45:32Z\"`\n    *    Format - date-time\n @property isUploaded (`boolean`) - Whether the file has been successfully uploaded.\n    *    Example - `true`\n @property mimeType (`string`) - MIME type of the file.\n    *    Example - `\"image/jpeg\"`\n @property uploadedByUserId? (`string`) - ID of the user who uploaded the file.\n    *    Example - `\"abc123def456\"`\n @property metadata? (`Record<string, unknown>`) - Custom metadata associated with the file.\n    *    Example - `{\"alt\":\"Profile picture\",\"category\":\"avatar\"}`*/\nexport interface FileMetadata {\n  /**\n   * Unique identifier for the file.\n   *    Example - `\"d5e76ceb-77a2-4153-b7da-1f7c115b2ff2\"`\n   */\n  id: string;\n  /**\n   * Name of the file including extension.\n   *    Example - `\"profile-picture.jpg\"`\n   */\n  name: string;\n  /**\n   * Size of the file in bytes.\n   *    Example - `245678`\n   *    Format - int64\n   */\n  size: number;\n  /**\n   * ID of the bucket containing the file.\n   *    Example - `\"users-bucket\"`\n   */\n  bucketId: string;\n  /**\n   * Entity tag for cache validation.\n   *    Example - `\"\\\"a1b2c3d4e5f6\\\"\"`\n   */\n  etag: string;\n  /**\n   * Timestamp when the file was created.\n   *    Example - `\"2023-01-15T12:34:56Z\"`\n   *    Format - date-time\n   */\n  createdAt: string;\n  /**\n   * Timestamp when the file was last updated.\n   *    Example - `\"2023-01-16T09:45:32Z\"`\n   *    Format - date-time\n   */\n  updatedAt: string;\n  /**\n   * Whether the file has been successfully uploaded.\n   *    Example - `true`\n   */\n  isUploaded: boolean;\n  /**\n   * MIME type of the file.\n   *    Example - `\"image/jpeg\"`\n   */\n  mimeType: string;\n  /**\n   * ID of the user who uploaded the file.\n   *    Example - `\"abc123def456\"`\n   */\n  uploadedByUserId?: string;\n  /**\n   * Custom metadata associated with the file.\n   *    Example - `{\"alt\":\"Profile picture\",\"category\":\"avatar\"}`\n   */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Basic information about a file in storage.\n @property id (`string`) - Unique identifier for the file.\n    *    Example - `\"d5e76ceb-77a2-4153-b7da-1f7c115b2ff2\"`\n @property name (`string`) - Name of the file including extension.\n    *    Example - `\"profile-picture.jpg\"`\n @property bucketId (`string`) - ID of the bucket containing the file.\n    *    Example - `\"users-bucket\"`\n @property isUploaded (`boolean`) - Whether the file has been successfully uploaded.\n    *    Example - `true`*/\nexport interface FileSummary {\n  /**\n   * Unique identifier for the file.\n   *    Example - `\"d5e76ceb-77a2-4153-b7da-1f7c115b2ff2\"`\n   */\n  id: string;\n  /**\n   * Name of the file including extension.\n   *    Example - `\"profile-picture.jpg\"`\n   */\n  name: string;\n  /**\n   * ID of the bucket containing the file.\n   *    Example - `\"users-bucket\"`\n   */\n  bucketId: string;\n  /**\n   * Whether the file has been successfully uploaded.\n   *    Example - `true`\n   */\n  isUploaded: boolean;\n}\n\n/**\n * Contains a presigned URL for direct file operations.\n @property url (`string`) - The presigned URL for file operations.\n    *    Example - `\"https://storage.example.com/files/abc123?signature=xyz\"`\n @property expiration (`number`) - The time in seconds until the URL expires.\n    *    Example - `3600`*/\nexport interface PresignedURLResponse {\n  /**\n   * The presigned URL for file operations.\n   *    Example - `\"https://storage.example.com/files/abc123?signature=xyz\"`\n   */\n  url: string;\n  /**\n   * The time in seconds until the URL expires.\n   *    Example - `3600`\n   */\n  expiration: number;\n}\n\n/**\n * Metadata that can be updated for an existing file.\n @property name? (`string`) - New name to assign to the file.\n    *    Example - `\"renamed-file.jpg\"`\n @property metadata? (`Record<string, unknown>`) - Updated custom metadata to associate with the file.\n    *    Example - `{\"alt\":\"Updated image description\",\"category\":\"profile\"}`*/\nexport interface UpdateFileMetadata {\n  /**\n   * New name to assign to the file.\n   *    Example - `\"renamed-file.jpg\"`\n   */\n  name?: string;\n  /**\n   * Updated custom metadata to associate with the file.\n   *    Example - `{\"alt\":\"Updated image description\",\"category\":\"profile\"}`\n   */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Metadata provided when uploading a new file.\n @property id? (`string`) - Optional custom ID for the file. If not provided, a UUID will be generated.\n    *    Example - `\"custom-id-123\"`\n @property name? (`string`) - Name to assign to the file. If not provided, the original filename will be used.\n    *    Example - `\"custom-filename.png\"`\n @property metadata? (`Record<string, unknown>`) - Custom metadata to associate with the file.\n    *    Example - `{\"alt\":\"Custom image\",\"category\":\"document\"}`*/\nexport interface UploadFileMetadata {\n  /**\n   * Optional custom ID for the file. If not provided, a UUID will be generated.\n   *    Example - `\"custom-id-123\"`\n   */\n  id?: string;\n  /**\n   * Name to assign to the file. If not provided, the original filename will be used.\n   *    Example - `\"custom-filename.png\"`\n   */\n  name?: string;\n  /**\n   * Custom metadata to associate with the file.\n   *    Example - `{\"alt\":\"Custom image\",\"category\":\"document\"}`\n   */\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * Contains version information about the storage service.\n @property buildVersion (`string`) - The version number of the storage service build.\n    *    Example - `\"1.2.3\"`*/\nexport interface VersionInformation {\n  /**\n   * The version number of the storage service build.\n   *    Example - `\"1.2.3\"`\n   */\n  buildVersion: string;\n}\n\n/**\n * Output format for image files. Use 'auto' for content negotiation based on Accept header\n */\nexport type OutputImageFormat =\n  | 'auto'\n  | 'same'\n  | 'jpeg'\n  | 'webp'\n  | 'png'\n  | 'avif'\n  | 'heic';\n\n/**\n * \n @property bucket-id? (`string`) - Target bucket identifier where files will be stored.\n    *    Example - `\"user-uploads\"`\n @property metadata[]? (`UploadFileMetadata[]`) - Optional custom metadata for each uploaded file. Must match the order of the file[] array.\n @property file[] (`Blob[]`) - Array of files to upload.*/\nexport interface UploadFilesBody {\n  /**\n   * Target bucket identifier where files will be stored.\n   *    Example - `\"user-uploads\"`\n   */\n  'bucket-id'?: string;\n  /**\n   * Optional custom metadata for each uploaded file. Must match the order of the file[] array.\n   */\n  'metadata[]'?: UploadFileMetadata[];\n  /**\n   * Array of files to upload.\n   */\n  'file[]': Blob[];\n}\n\n/**\n * \n @property processedFiles (`FileMetadata[]`) - List of successfully processed files with their metadata.*/\nexport interface UploadFilesResponse201 {\n  /**\n   * List of successfully processed files with their metadata.\n   */\n  processedFiles: FileMetadata[];\n}\n\n/**\n * \n @property metadata? (`UpdateFileMetadata`) - Metadata that can be updated for an existing file.\n @property file? (`Blob`) - New file content to replace the existing file\n    *    Format - binary*/\nexport interface ReplaceFileBody {\n  /**\n   * Metadata that can be updated for an existing file.\n   */\n  metadata?: UpdateFileMetadata;\n  /**\n   * New file content to replace the existing file\n   *    Format - binary\n   */\n  file?: Blob;\n}\n\n/**\n * \n @property metadata? (`FileSummary[]`) - */\nexport interface DeleteBrokenMetadataResponse200 {\n  /**\n   *\n   */\n  metadata?: FileSummary[];\n}\n\n/**\n * \n @property files? (`string[]`) - */\nexport interface DeleteOrphanedFilesResponse200 {\n  /**\n   *\n   */\n  files?: string[];\n}\n\n/**\n * \n @property metadata? (`FileSummary[]`) - */\nexport interface ListBrokenMetadataResponse200 {\n  /**\n   *\n   */\n  metadata?: FileSummary[];\n}\n\n/**\n * \n @property metadata? (`FileSummary[]`) - */\nexport interface ListFilesNotUploadedResponse200 {\n  /**\n   *\n   */\n  metadata?: FileSummary[];\n}\n\n/**\n * \n @property files? (`string[]`) - */\nexport interface ListOrphanedFilesResponse200 {\n  /**\n   *\n   */\n  files?: string[];\n}\n\n/**\n * Parameters for the getFile method.\n    @property q? (number) - Image quality (1-100). Only applies to JPEG, WebP, PNG and HEIC files\n  \n    @property h? (number) - Maximum height to resize image to while maintaining aspect ratio. Only applies to image files\n  \n    @property w? (number) - Maximum width to resize image to while maintaining aspect ratio. Only applies to image files\n  \n    @property b? (number) - Blur the image using this sigma value. Only applies to image files\n  \n    @property f? (OutputImageFormat) - Output format for image files. Use 'auto' for content negotiation based on Accept header\n  \n    *    Output format for image files. Use 'auto' for content negotiation based on Accept header*/\nexport interface GetFileParams {\n  /**\n   * Image quality (1-100). Only applies to JPEG, WebP, PNG and HEIC files\n  \n   */\n  q?: number;\n  /**\n   * Maximum height to resize image to while maintaining aspect ratio. Only applies to image files\n  \n   */\n  h?: number;\n  /**\n   * Maximum width to resize image to while maintaining aspect ratio. Only applies to image files\n  \n   */\n  w?: number;\n  /**\n   * Blur the image using this sigma value. Only applies to image files\n  \n   */\n  b?: number;\n  /**\n   * Output format for image files. Use 'auto' for content negotiation based on Accept header\n  \n    *    Output format for image files. Use 'auto' for content negotiation based on Accept header\n   */\n  f?: OutputImageFormat;\n}\n/**\n * Parameters for the getFileMetadataHeaders method.\n    @property q? (number) - Image quality (1-100). Only applies to JPEG, WebP, PNG and HEIC files\n  \n    @property h? (number) - Maximum height to resize image to while maintaining aspect ratio. Only applies to image files\n  \n    @property w? (number) - Maximum width to resize image to while maintaining aspect ratio. Only applies to image files\n  \n    @property b? (number) - Blur the image using this sigma value. Only applies to image files\n  \n    @property f? (OutputImageFormat) - Output format for image files. Use 'auto' for content negotiation based on Accept header\n  \n    *    Output format for image files. Use 'auto' for content negotiation based on Accept header*/\nexport interface GetFileMetadataHeadersParams {\n  /**\n   * Image quality (1-100). Only applies to JPEG, WebP, PNG and HEIC files\n  \n   */\n  q?: number;\n  /**\n   * Maximum height to resize image to while maintaining aspect ratio. Only applies to image files\n  \n   */\n  h?: number;\n  /**\n   * Maximum width to resize image to while maintaining aspect ratio. Only applies to image files\n  \n   */\n  w?: number;\n  /**\n   * Blur the image using this sigma value. Only applies to image files\n  \n   */\n  b?: number;\n  /**\n   * Output format for image files. Use 'auto' for content negotiation based on Accept header\n  \n    *    Output format for image files. Use 'auto' for content negotiation based on Accept header\n   */\n  f?: OutputImageFormat;\n}\n\nexport interface Client {\n  baseURL: string;\n\n  /** Add a middleware function to the fetch chain\n   * @param chainFunction - The middleware function to add\n   */\n  pushChainFunction(chainFunction: ChainFunction): void;\n  /**\n     Summary: Upload files\n     Upload one or more files to a specified bucket. Supports batch uploading with optional custom metadata for each file. If uploading multiple files, either provide metadata for all files or none.\n\n     This method may return different T based on the response code:\n     - 201: UploadFilesResponse201\n     */\n  uploadFiles(\n    body: UploadFilesBody,\n    options?: RequestInit,\n  ): Promise<FetchResponse<UploadFilesResponse201>>;\n\n  /**\n     Summary: Delete file\n     Permanently delete a file from storage. This removes both the file content and its associated metadata.\n\n     This method may return different T based on the response code:\n     - 204: void\n     */\n  deleteFile(id: string, options?: RequestInit): Promise<FetchResponse<void>>;\n\n  /**\n     Summary: Download file\n     Retrieve and download the complete file content. Supports conditional requests, image transformations, and range requests for partial downloads.\n\n     This method may return different T based on the response code:\n     - 200: void\n     - 206: void\n     - 304: void\n     - 412: void\n     */\n  getFile(\n    id: string,\n    params?: GetFileParams,\n    options?: RequestInit,\n  ): Promise<FetchResponse<Blob>>;\n\n  /**\n     Summary: Check file information\n     Retrieve file metadata headers without downloading the file content. Supports conditional requests and provides caching information.\n\n     This method may return different T based on the response code:\n     - 200: void\n     - 304: void\n     - 412: void\n     */\n  getFileMetadataHeaders(\n    id: string,\n    params?: GetFileMetadataHeadersParams,\n    options?: RequestInit,\n  ): Promise<FetchResponse<void>>;\n\n  /**\n     Summary: Replace file\n     Replace an existing file with new content while preserving the file ID. The operation follows these steps:\n1. The isUploaded flag is set to false to mark the file as being updated\n2. The file content is replaced in the storage backend\n3. File metadata is updated (size, mime-type, isUploaded, etc.)\n\nEach step is atomic, but if a step fails, previous steps will not be automatically rolled back.\n\n\n     This method may return different T based on the response code:\n     - 200: FileMetadata\n     */\n  replaceFile(\n    id: string,\n    body: ReplaceFileBody,\n    options?: RequestInit,\n  ): Promise<FetchResponse<FileMetadata>>;\n\n  /**\n     Summary: Retrieve presigned URL to retrieve the file\n     Retrieve presigned URL to retrieve the file. Expiration of the URL is\ndetermined by bucket configuration\n\n\n     This method may return different T based on the response code:\n     - 200: PresignedURLResponse\n     */\n  getFilePresignedURL(\n    id: string,\n    options?: RequestInit,\n  ): Promise<FetchResponse<PresignedURLResponse>>;\n\n  /**\n     Summary: Delete broken metadata\n     Broken metadata is defined as metadata that has isUploaded = true but there is no file in the storage matching it. This is an admin operation that requires the Hasura admin secret.\n\n     This method may return different T based on the response code:\n     - 200: DeleteBrokenMetadataResponse200\n     */\n  deleteBrokenMetadata(\n    options?: RequestInit,\n  ): Promise<FetchResponse<DeleteBrokenMetadataResponse200>>;\n\n  /**\n     Summary: Deletes orphaned files\n     Orphaned files are files that are present in the storage but have no associated metadata. This is an admin operation that requires the Hasura admin secret.\n\n     This method may return different T based on the response code:\n     - 200: DeleteOrphanedFilesResponse200\n     */\n  deleteOrphanedFiles(\n    options?: RequestInit,\n  ): Promise<FetchResponse<DeleteOrphanedFilesResponse200>>;\n\n  /**\n     Summary: Lists broken metadata\n     Broken metadata is defined as metadata that has isUploaded = true but there is no file in the storage matching it. This is an admin operation that requires the Hasura admin secret.\n\n     This method may return different T based on the response code:\n     - 200: ListBrokenMetadataResponse200\n     */\n  listBrokenMetadata(\n    options?: RequestInit,\n  ): Promise<FetchResponse<ListBrokenMetadataResponse200>>;\n\n  /**\n     Summary: Lists files that haven't been uploaded\n     That is, metadata that has isUploaded = false. This is an admin operation that requires the Hasura admin secret.\n\n     This method may return different T based on the response code:\n     - 200: ListFilesNotUploadedResponse200\n     */\n  listFilesNotUploaded(\n    options?: RequestInit,\n  ): Promise<FetchResponse<ListFilesNotUploadedResponse200>>;\n\n  /**\n     Summary: Lists orphaned files\n     Orphaned files are files that are present in the storage but have no associated metadata. This is an admin operation that requires the Hasura admin secret.\n\n     This method may return different T based on the response code:\n     - 200: ListOrphanedFilesResponse200\n     */\n  listOrphanedFiles(\n    options?: RequestInit,\n  ): Promise<FetchResponse<ListOrphanedFilesResponse200>>;\n\n  /**\n     Summary: Get service version information\n     Retrieves build and version information about the storage service. Useful for monitoring and debugging.\n\n     This method may return different T based on the response code:\n     - 200: VersionInformation\n     */\n  getVersion(options?: RequestInit): Promise<FetchResponse<VersionInformation>>;\n}\n\nexport const createAPIClient = (\n  baseURL: string,\n  chainFunctions: ChainFunction[] = [],\n): Client => {\n  let fetch = createEnhancedFetch(chainFunctions);\n\n  const pushChainFunction = (chainFunction: ChainFunction) => {\n    chainFunctions.push(chainFunction);\n    fetch = createEnhancedFetch(chainFunctions);\n  };\n  const uploadFiles = async (\n    body: UploadFilesBody,\n    options?: RequestInit,\n  ): Promise<FetchResponse<UploadFilesResponse201>> => {\n    const url = `${baseURL}/files`;\n    const formData = new FormData();\n    const isReactNative =\n      typeof navigator !== 'undefined' &&\n      (navigator as { product?: string }).product === 'ReactNative';\n    if (body['bucket-id'] !== undefined) {\n      formData.append('bucket-id', body['bucket-id']);\n    }\n    if (body['metadata[]'] !== undefined) {\n      body['metadata[]'].forEach((value) => {\n        if (isReactNative) {\n          formData.append('metadata[]', {\n            string: JSON.stringify(value),\n            type: 'application/json',\n            name: '',\n          } as unknown as Blob);\n        } else {\n          formData.append(\n            'metadata[]',\n            new Blob([JSON.stringify(value)], { type: 'application/json' }),\n            '',\n          );\n        }\n      });\n    }\n    if (body['file[]'] !== undefined) {\n      body['file[]'].forEach((value) => {\n        formData.append('file[]', value);\n      });\n    }\n\n    const res = await fetch(url, {\n      ...options,\n      method: 'POST',\n      body: formData,\n    });\n\n    if (res.status >= 300) {\n      const responseBody = [412].includes(res.status) ? null : await res.text();\n      const payload: unknown = responseBody ? JSON.parse(responseBody) : {};\n      throw new FetchError(payload, res.status, res.headers);\n    }\n\n    const responseBody = [204, 205, 304].includes(res.status)\n      ? null\n      : await res.text();\n    const payload: UploadFilesResponse201 = responseBody\n      ? JSON.parse(responseBody)\n      : {};\n\n    return {\n      body: payload,\n      status: res.status,\n      headers: res.headers,\n    } as FetchResponse<UploadFilesResponse201>;\n  };\n\n  const deleteFile = async (\n    id: string,\n    options?: RequestInit,\n  ): Promise<FetchResponse<void>> => {\n    const url = `${baseURL}/files/${id}`;\n    const res = await fetch(url, {\n      ...options,\n      method: 'DELETE',\n      headers: {\n        ...options?.headers,\n      },\n    });\n\n    if (res.status >= 300) {\n      const responseBody = [412].includes(res.status) ? null : await res.text();\n      const payload: unknown = responseBody ? JSON.parse(responseBody) : {};\n      throw new FetchError(payload, res.status, res.headers);\n    }\n\n    const payload: undefined = undefined;\n\n    return {\n      body: payload,\n      status: res.status,\n      headers: res.headers,\n    } as FetchResponse<void>;\n  };\n\n  const getFile = async (\n    id: string,\n    params?: GetFileParams,\n    options?: RequestInit,\n  ): Promise<FetchResponse<Blob>> => {\n    const encodedParameters =\n      params &&\n      Object.entries(params)\n        .flatMap(([key, value]) => {\n          // Default handling (scalars or explode: false)\n          const stringValue = Array.isArray(value)\n            ? value.join(',')\n            : typeof value === 'object' && value !== null\n              ? JSON.stringify(value)\n              : String(value);\n          return [`${key}=${encodeURIComponent(stringValue)}`];\n        })\n        .join('&');\n\n    const url = encodedParameters\n      ? `${baseURL}/files/${id}?${encodedParameters}`\n      : `${baseURL}/files/${id}`;\n    const res = await fetch(url, {\n      ...options,\n      method: 'GET',\n      headers: {\n        ...options?.headers,\n      },\n    });\n\n    if (res.status >= 300) {\n      const responseBody = [412].includes(res.status) ? null : await res.text();\n      const payload: unknown = responseBody ? JSON.parse(responseBody) : {};\n      throw new FetchError(payload, res.status, res.headers);\n    }\n\n    const payload: Blob = await res.blob();\n\n    return {\n      body: payload,\n      status: res.status,\n      headers: res.headers,\n    } as FetchResponse<Blob>;\n  };\n\n  const getFileMetadataHeaders = async (\n    id: string,\n    params?: GetFileMetadataHeadersParams,\n    options?: RequestInit,\n  ): Promise<FetchResponse<void>> => {\n    const encodedParameters =\n      params &&\n      Object.entries(params)\n        .flatMap(([key, value]) => {\n          // Default handling (scalars or explode: false)\n          const stringValue = Array.isArray(value)\n            ? value.join(',')\n            : typeof value === 'object' && value !== null\n              ? JSON.stringify(value)\n              : String(value);\n          return [`${key}=${encodeURIComponent(stringValue)}`];\n        })\n        .join('&');\n\n    const url = encodedParameters\n      ? `${baseURL}/files/${id}?${encodedParameters}`\n      : `${baseURL}/files/${id}`;\n    const res = await fetch(url, {\n      ...options,\n      method: 'HEAD',\n      headers: {\n        ...options?.headers,\n      },\n    });\n\n    if (res.status >= 300) {\n      const responseBody = [412].includes(res.status) ? null : await res.text();\n      const payload: unknown = responseBody ? JSON.parse(responseBody) : {};\n      throw new FetchError(payload, res.status, res.headers);\n    }\n\n    const payload: undefined = undefined;\n\n    return {\n      body: payload,\n      status: res.status,\n      headers: res.headers,\n    } as FetchResponse<void>;\n  };\n\n  const replaceFile = async (\n    id: string,\n    body: ReplaceFileBody,\n    options?: RequestInit,\n  ): Promise<FetchResponse<FileMetadata>> => {\n    const url = `${baseURL}/files/${id}`;\n    const formData = new FormData();\n    const isReactNative =\n      typeof navigator !== 'undefined' &&\n      (navigator as { product?: string }).product === 'ReactNative';\n    if (body['metadata'] !== undefined) {\n      if (isReactNative) {\n        formData.append('metadata', {\n          string: JSON.stringify(body['metadata']),\n          type: 'application/json',\n          name: '',\n        } as unknown as Blob);\n      } else {\n        formData.append(\n          'metadata',\n          new Blob([JSON.stringify(body['metadata'])], {\n            type: 'application/json',\n          }),\n          '',\n        );\n      }\n    }\n    if (body['file'] !== undefined) {\n      formData.append('file', body['file']);\n    }\n\n    const res = await fetch(url, {\n      ...options,\n      method: 'PUT',\n      body: formData,\n    });\n\n    if (res.status >= 300) {\n      const responseBody = [412].includes(res.status) ? null : await res.text();\n      const payload: unknown = responseBody ? JSON.parse(responseBody) : {};\n      throw new FetchError(payload, res.status, res.headers);\n    }\n\n    const responseBody = [204, 205, 304].includes(res.status)\n      ? null\n      : await res.text();\n    const payload: FileMetadata = responseBody ? JSON.parse(responseBody) : {};\n\n    return {\n      body: payload,\n      status: res.status,\n      headers: res.headers,\n    } as FetchResponse<FileMetadata>;\n  };\n\n  const getFilePresignedURL = async (\n    id: string,\n    options?: RequestInit,\n  ): Promise<FetchResponse<PresignedURLResponse>> => {\n    const url = `${baseURL}/files/${id}/presignedurl`;\n    const res = await fetch(url, {\n      ...options,\n      method: 'GET',\n      headers: {\n        ...options?.headers,\n      },\n    });\n\n    if (res.status >= 300) {\n      const responseBody = [412].includes(res.status) ? null : await res.text();\n      const payload: unknown = responseBody ? JSON.parse(responseBody) : {};\n      throw new FetchError(payload, res.status, res.headers);\n    }\n\n    const responseBody = [204, 205, 304].includes(res.status)\n      ? null\n      : await res.text();\n    const payload: PresignedURLResponse = responseBody\n      ? JSON.parse(responseBody)\n      : {};\n\n    return {\n      body: payload,\n      status: res.status,\n      headers: res.headers,\n    } as FetchResponse<PresignedURLResponse>;\n  };\n\n  const deleteBrokenMetadata = async (\n    options?: RequestInit,\n  ): Promise<FetchResponse<DeleteBrokenMetadataResponse200>> => {\n    const url = `${baseURL}/ops/delete-broken-metadata`;\n    const res = await fetch(url, {\n      ...options,\n      method: 'POST',\n      headers: {\n        ...options?.headers,\n      },\n    });\n\n    if (res.status >= 300) {\n      const responseBody = [412].includes(res.status) ? null : await res.text();\n      const payload: unknown = responseBody ? JSON.parse(responseBody) : {};\n      throw new FetchError(payload, res.status, res.headers);\n    }\n\n    const responseBody = [204, 205, 304].includes(res.status)\n      ? null\n      : await res.text();\n    const payload: DeleteBrokenMetadataResponse200 = responseBody\n      ? JSON.parse(responseBody)\n      : {};\n\n    return {\n      body: payload,\n      status: res.status,\n      headers: res.headers,\n    } as FetchResponse<DeleteBrokenMetadataResponse200>;\n  };\n\n  const deleteOrphanedFiles = async (\n    options?: RequestInit,\n  ): Promise<FetchResponse<DeleteOrphanedFilesResponse200>> => {\n    const url = `${baseURL}/ops/delete-orphans`;\n    const res = await fetch(url, {\n      ...options,\n      method: 'POST',\n      headers: {\n        ...options?.headers,\n      },\n    });\n\n    if (res.status >= 300) {\n      const responseBody = [412].includes(res.status) ? null : await res.text();\n      const payload: unknown = responseBody ? JSON.parse(responseBody) : {};\n      throw new FetchError(payload, res.status, res.headers);\n    }\n\n    const responseBody = [204, 205, 304].includes(res.status)\n      ? null\n      : await res.text();\n    const payload: DeleteOrphanedFilesResponse200 = responseBody\n      ? JSON.parse(responseBody)\n      : {};\n\n    return {\n      body: payload,\n      status: res.status,\n      headers: res.headers,\n    } as FetchResponse<DeleteOrphanedFilesResponse200>;\n  };\n\n  const listBrokenMetadata = async (\n    options?: RequestInit,\n  ): Promise<FetchResponse<ListBrokenMetadataResponse200>> => {\n    const url = `${baseURL}/ops/list-broken-metadata`;\n    const res = await fetch(url, {\n      ...options,\n      method: 'POST',\n      headers: {\n        ...options?.headers,\n      },\n    });\n\n    if (res.status >= 300) {\n      const responseBody = [412].includes(res.status) ? null : await res.text();\n      const payload: unknown = responseBody ? JSON.parse(responseBody) : {};\n      throw new FetchError(payload, res.status, res.headers);\n    }\n\n    const responseBody = [204, 205, 304].includes(res.status)\n      ? null\n      : await res.text();\n    const payload: ListBrokenMetadataResponse200 = responseBody\n      ? JSON.parse(responseBody)\n      : {};\n\n    return {\n      body: payload,\n      status: res.status,\n      headers: res.headers,\n    } as FetchResponse<ListBrokenMetadataResponse200>;\n  };\n\n  const listFilesNotUploaded = async (\n    options?: RequestInit,\n  ): Promise<FetchResponse<ListFilesNotUploadedResponse200>> => {\n    const url = `${baseURL}/ops/list-not-uploaded`;\n    const res = await fetch(url, {\n      ...options,\n      method: 'POST',\n      headers: {\n        ...options?.headers,\n      },\n    });\n\n    if (res.status >= 300) {\n      const responseBody = [412].includes(res.status) ? null : await res.text();\n      const payload: unknown = responseBody ? JSON.parse(responseBody) : {};\n      throw new FetchError(payload, res.status, res.headers);\n    }\n\n    const responseBody = [204, 205, 304].includes(res.status)\n      ? null\n      : await res.text();\n    const payload: ListFilesNotUploadedResponse200 = responseBody\n      ? JSON.parse(responseBody)\n      : {};\n\n    return {\n      body: payload,\n      status: res.status,\n      headers: res.headers,\n    } as FetchResponse<ListFilesNotUploadedResponse200>;\n  };\n\n  const listOrphanedFiles = async (\n    options?: RequestInit,\n  ): Promise<FetchResponse<ListOrphanedFilesResponse200>> => {\n    const url = `${baseURL}/ops/list-orphans`;\n    const res = await fetch(url, {\n      ...options,\n      method: 'POST',\n      headers: {\n        ...options?.headers,\n      },\n    });\n\n    if (res.status >= 300) {\n      const responseBody = [412].includes(res.status) ? null : await res.text();\n      const payload: unknown = responseBody ? JSON.parse(responseBody) : {};\n      throw new FetchError(payload, res.status, res.headers);\n    }\n\n    const responseBody = [204, 205, 304].includes(res.status)\n      ? null\n      : await res.text();\n    const payload: ListOrphanedFilesResponse200 = responseBody\n      ? JSON.parse(responseBody)\n      : {};\n\n    return {\n      body: payload,\n      status: res.status,\n      headers: res.headers,\n    } as FetchResponse<ListOrphanedFilesResponse200>;\n  };\n\n  const getVersion = async (\n    options?: RequestInit,\n  ): Promise<FetchResponse<VersionInformation>> => {\n    const url = `${baseURL}/version`;\n    const res = await fetch(url, {\n      ...options,\n      method: 'GET',\n      headers: {\n        ...options?.headers,\n      },\n    });\n\n    if (res.status >= 300) {\n      const responseBody = [412].includes(res.status) ? null : await res.text();\n      const payload: unknown = responseBody ? JSON.parse(responseBody) : {};\n      throw new FetchError(payload, res.status, res.headers);\n    }\n\n    const responseBody = [204, 205, 304].includes(res.status)\n      ? null\n      : await res.text();\n    const payload: VersionInformation = responseBody\n      ? JSON.parse(responseBody)\n      : {};\n\n    return {\n      body: payload,\n      status: res.status,\n      headers: res.headers,\n    } as FetchResponse<VersionInformation>;\n  };\n\n  return {\n    baseURL,\n    pushChainFunction,\n    uploadFiles,\n    deleteFile,\n    getFile,\n    getFileMetadataHeaders,\n    replaceFile,\n    getFilePresignedURL,\n    deleteBrokenMetadata,\n    deleteOrphanedFiles,\n    listBrokenMetadata,\n    listFilesNotUploaded,\n    listOrphanedFiles,\n    getVersion,\n  };\n};\n"],"names":["baseURL","chainFunctions","fetch","createEnhancedFetch","pushChainFunction","chainFunction","push","uploadFiles","async","body","options","url","formData","FormData","isReactNative","navigator","product","append","forEach","value","string","JSON","stringify","type","name","Blob","res","method","status","responseBody","includes","text","payload","parse","FetchError","headers","deleteFile","id","getFile","params","encodedParameters","Object","entries","flatMap","key","stringValue","Array","isArray","join","String","encodeURIComponent","blob","getFileMetadataHeaders","replaceFile","getFilePresignedURL","deleteBrokenMetadata","deleteOrphanedFiles","listBrokenMetadata","listFilesNotUploaded","listOrphanedFiles","getVersion"],"mappings":"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"}