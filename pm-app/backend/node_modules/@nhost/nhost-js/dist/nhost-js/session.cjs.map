{"version":3,"file":"session.cjs","sources":["../../src/session/session.ts","../../src/session/storageBackend.ts","../../src/session/storage.ts"],"sourcesContent":["import type { Session as AuthSession } from '../auth';\n\n/**\n * Decoded JWT token payload with processed timestamps and Hasura claims\n */\nexport interface DecodedToken {\n  /** Token expiration time as Date object */\n  exp?: number;\n  /** Token issued at time as Date object */\n  iat?: number;\n  /** Token issuer */\n  iss?: string;\n  /** Token subject (user ID) */\n  sub?: string;\n  /** Hasura JWT claims with PostgreSQL arrays converted to JavaScript arrays */\n  'https://hasura.io/jwt/claims'?: Record<string, unknown>;\n  /** Any other JWT claims */\n  [key: string]: unknown;\n}\n\nexport interface Session extends AuthSession {\n  /** Decoded JWT token payload with processed timestamps and Hasura claims */\n  decodedToken: DecodedToken;\n}\n\nexport const decodeUserSession = (accessToken: string): DecodedToken => {\n  const s = accessToken.split('.');\n  if (s.length !== 3 || !s[1]) {\n    throw new Error('Invalid access token format');\n  }\n\n  const decodedToken = JSON.parse(\n    typeof atob !== 'undefined'\n      ? atob(s[1])\n      : Buffer.from(s[1], 'base64').toString('utf-8'),\n  ) as Record<string, unknown>;\n\n  // Convert iat and exp to Date objects\n  const iat =\n    typeof decodedToken['iat'] === 'number'\n      ? decodedToken['iat'] * 1000 // Convert seconds to milliseconds\n      : undefined;\n  const exp =\n    typeof decodedToken['exp'] === 'number'\n      ? decodedToken['exp'] * 1000 // Convert seconds to milliseconds\n      : undefined;\n\n  // Process Hasura claims - dynamically convert PostgreSQL array notation to arrays\n  const hasuraClaims = decodedToken['https://hasura.io/jwt/claims'] as\n    | Record<string, unknown>\n    | undefined;\n  const processedClaims = hasuraClaims\n    ? Object.entries(hasuraClaims).reduce(\n        (acc, [key, value]) => {\n          if (typeof value === 'string' && isPostgresArray(value)) {\n            acc[key] = parsePostgresArray(value);\n          } else {\n            acc[key] = value;\n          }\n          return acc;\n        },\n        {} as Record<string, unknown>,\n      )\n    : undefined;\n\n  return {\n    ...decodedToken,\n    iat,\n    exp,\n    'https://hasura.io/jwt/claims': processedClaims,\n  };\n};\n\nconst isPostgresArray = (value: string): boolean => {\n  return value.startsWith('{') && value.endsWith('}');\n};\n\nconst parsePostgresArray = (value: string): string[] => {\n  if (!value || value === '{}') return [];\n  // Remove curly braces and split by comma, handling quoted values\n  return value\n    .slice(1, -1)\n    .split(',')\n    .map((item) => item.trim().replace(/^\"(.*)\"$/, '$1'));\n};\n","/**\n * Storage implementations for session persistence in different environments.\n *\n * This module provides different storage adapters for persisting authentication sessions\n * across page reloads and browser sessions.\n */\n\nimport type { Session } from './session';\n\n/**\n * Session storage interface for session persistence.\n * This interface can be implemented to provide custom storage solutions.\n */\nexport interface SessionStorageBackend {\n  /**\n   * Get the current session from storage\n   * @returns The stored session or null if not found\n   */\n  get(): Session | null;\n\n  /**\n   * Set the session in storage\n   * @param value - The session to store\n   */\n  set(value: Session): void;\n\n  /**\n   * Remove the session from storage\n   */\n  remove(): void;\n}\n\n/**\n * Default storage key used for storing the Nhost session\n */\nexport const DEFAULT_SESSION_KEY = 'nhostSession';\n\n/**\n * Browser localStorage implementation of StorageInterface.\n * Persists the session across page reloads and browser restarts.\n */\nexport class LocalStorage implements SessionStorageBackend {\n  private readonly storageKey: string;\n\n  /**\n   * Creates a new LocalStorage instance\n   * @param options - Configuration options\n   * @param options.storageKey - The key to use in localStorage (defaults to \"nhostSession\")\n   */\n  constructor(options?: { storageKey?: string }) {\n    this.storageKey = options?.storageKey || DEFAULT_SESSION_KEY;\n  }\n\n  /**\n   * Gets the session from localStorage\n   * @returns The stored session or null if not found\n   */\n  get(): Session | null {\n    try {\n      const value = window.localStorage.getItem(this.storageKey);\n      return value ? (JSON.parse(value) as Session) : null;\n    } catch {\n      this.remove();\n      return null;\n    }\n  }\n\n  /**\n   * Sets the session in localStorage\n   * @param value - The session to store\n   */\n  set(value: Session): void {\n    window.localStorage.setItem(this.storageKey, JSON.stringify(value));\n  }\n\n  /**\n   * Removes the session from localStorage\n   */\n  remove(): void {\n    window.localStorage.removeItem(this.storageKey);\n  }\n}\n\n/**\n * In-memory storage implementation for non-browser environments or when\n * persistent storage is not available or desirable.\n */\nexport class MemoryStorage implements SessionStorageBackend {\n  private session: Session | null = null;\n\n  /**\n   * Gets the session from memory\n   * @returns The stored session or null if not set\n   */\n  get(): Session | null {\n    return this.session;\n  }\n\n  /**\n   * Sets the session in memory\n   * @param value - The session to store\n   */\n  set(value: Session): void {\n    this.session = value;\n  }\n\n  /**\n   * Clears the session from memory\n   */\n  remove(): void {\n    this.session = null;\n  }\n}\n\n/**\n * Cookie-based storage implementation.\n * This storage uses web browser cookies to store the session so it's not\n * available in server-side environments. It is useful though for synchronizing\n * sessions between client and server environments.\n */\nexport class CookieStorage implements SessionStorageBackend {\n  private readonly cookieName: string;\n  private readonly expirationDays: number;\n  private readonly secure: boolean;\n  private readonly sameSite: 'strict' | 'lax' | 'none';\n\n  /**\n   * Creates a new CookieStorage instance\n   * @param options - Configuration options\n   * @param options.cookieName - Name of the cookie to use (defaults to \"nhostSession\")\n   * @param options.expirationDays - Number of days until the cookie expires (defaults to 30)\n   * @param options.secure - Whether to set the Secure flag on the cookie (defaults to true)\n   * @param options.sameSite - SameSite policy for the cookie (defaults to \"lax\")\n   */\n  constructor(options?: {\n    cookieName?: string;\n    expirationDays?: number;\n    secure?: boolean;\n    sameSite?: 'strict' | 'lax' | 'none';\n  }) {\n    this.cookieName = options?.cookieName || DEFAULT_SESSION_KEY;\n    this.expirationDays = options?.expirationDays ?? 30;\n    this.secure = options?.secure ?? true;\n    this.sameSite = options?.sameSite || 'lax';\n  }\n\n  /**\n   * Gets the session from cookies\n   * @returns The stored session or null if not found\n   */\n  get(): Session | null {\n    const cookies = document.cookie.split(';');\n    for (const cookie of cookies) {\n      const [name, value] = cookie.trim().split('=');\n      if (name === this.cookieName) {\n        try {\n          return JSON.parse(decodeURIComponent(value || '')) as Session;\n        } catch {\n          this.remove();\n          return null;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Sets the session in a cookie\n   * @param value - The session to store\n   */\n  set(value: Session): void {\n    const expires = new Date();\n    expires.setTime(\n      expires.getTime() + this.expirationDays * 24 * 60 * 60 * 1000,\n    );\n\n    const cookieValue = encodeURIComponent(JSON.stringify(value));\n    const cookieString = `${this.cookieName}=${cookieValue}; expires=${expires.toUTCString()}; path=/; ${this.secure ? 'secure; ' : ''}SameSite=${this.sameSite}`;\n\n    // biome-ignore lint/suspicious/noDocumentCookie: this is unnecessary\n    document.cookie = cookieString;\n  }\n\n  /**\n   * Removes the session cookie\n   */\n  remove(): void {\n    // biome-ignore lint/suspicious/noDocumentCookie: this is unnecessary\n    document.cookie = `${this.cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/; ${this.secure ? 'secure; ' : ''}SameSite=${this.sameSite}`;\n  }\n}\n","/**\n * Storage implementations for session persistence in different environments.\n *\n * This module provides different storage adapters for persisting authentication sessions\n * across page reloads and browser sessions.\n */\n\nimport type { Session as AuthSession } from '../auth';\nimport { decodeUserSession, type Session } from './session';\nimport {\n  LocalStorage,\n  MemoryStorage,\n  type SessionStorageBackend,\n} from './storageBackend';\n\n/**\n * Callback function type for session change subscriptions\n */\nexport type SessionChangeCallback = (session: Session | null) => void;\n\n/**\n * A wrapper around any SessionStorageInterface implementation that adds\n * the ability to subscribe to session changes.\n */\nexport class SessionStorage {\n  private readonly storage: SessionStorageBackend;\n  private subscribers = new Set<SessionChangeCallback>();\n\n  /**\n   * Creates a new SessionStorage instance\n   * @param storage - The underlying storage implementation to use\n   */\n  constructor(storage: SessionStorageBackend) {\n    this.storage = storage;\n  }\n\n  /**\n   * Gets the session from the underlying storage\n   * @returns The stored session or null if not found\n   */\n  get(): Session | null {\n    return this.storage.get();\n  }\n\n  /**\n   * Sets the session in the underlying storage and notifies subscribers\n   * @param value - The session to store\n   */\n  set(value: AuthSession): void {\n    const decodedToken = decodeUserSession(value.accessToken);\n    const decodedSession = {\n      ...value,\n      decodedToken: decodedToken,\n    };\n\n    this.storage.set(decodedSession);\n    this.notifySubscribers(decodedSession);\n  }\n\n  /**\n   * Removes the session from the underlying storage and notifies subscribers\n   */\n  remove(): void {\n    this.storage.remove();\n    this.notifySubscribers(null);\n  }\n\n  /**\n   * Subscribe to session changes\n   * @param callback - Function that will be called when the session changes\n   * @returns An unsubscribe function to remove this subscription\n   */\n  onChange(callback: SessionChangeCallback) {\n    this.subscribers.add(callback);\n\n    return () => {\n      this.subscribers.delete(callback);\n    };\n  }\n\n  /**\n   * Notify all subscribers of a session change\n   * @param session - The new session value or null if removed\n   */\n  private notifySubscribers(session: Session | null): void {\n    for (const subscriber of this.subscribers) {\n      try {\n        subscriber(session);\n      } catch (error) {\n        console.error('Error notifying subscriber:', error);\n      }\n    }\n  }\n}\n\n/**\n * Detects the best available storage implementation for the current environment.\n *\n * The detection process follows this order:\n * 1. Try to use localStorage if we're in a browser environment\n * 2. Fall back to in-memory storage if localStorage isn't available\n *\n * @returns The best available storage implementation as a SessionStorageBackend\n */\nexport const detectStorage = (): SessionStorageBackend => {\n  if (typeof window !== 'undefined') {\n    return new LocalStorage();\n  }\n  return new MemoryStorage();\n};\n"],"names":["isPostgresArray","value","startsWith","endsWith","parsePostgresArray","slice","split","map","item","trim","replace","DEFAULT_SESSION_KEY","LocalStorage","storageKey","constructor","options","this","get","window","localStorage","getItem","JSON","parse","remove","set","setItem","stringify","removeItem","MemoryStorage","session","cookieName","expirationDays","secure","sameSite","cookies","document","cookie","name","decodeURIComponent","expires","Date","setTime","getTime","cookieValue","encodeURIComponent","cookieString","toUTCString","storage","subscribers","Set","decodedToken","accessToken","s","length","Error","atob","Buffer","from","toString","iat","exp","hasuraClaims","processedClaims","Object","entries","reduce","acc","key","decodeUserSession","decodedSession","notifySubscribers","onChange","callback","add","delete","subscriber","error","console"],"mappings":"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"}