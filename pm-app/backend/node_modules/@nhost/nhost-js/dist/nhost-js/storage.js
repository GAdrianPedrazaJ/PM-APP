import { c as createEnhancedFetch, F as FetchError } from "../fetch-2PHmQBIJ.js";
const createAPIClient = (baseURL, chainFunctions = []) => {
  let fetch = createEnhancedFetch(chainFunctions);
  const pushChainFunction = (chainFunction) => {
    chainFunctions.push(chainFunction);
    fetch = createEnhancedFetch(chainFunctions);
  };
  const uploadFiles = async (body, options) => {
    const url = `${baseURL}/files`;
    const formData = new FormData();
    const isReactNative = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    if (body["bucket-id"] !== void 0) {
      formData.append("bucket-id", body["bucket-id"]);
    }
    if (body["metadata[]"] !== void 0) {
      body["metadata[]"].forEach((value) => {
        if (isReactNative) {
          formData.append("metadata[]", {
            string: JSON.stringify(value),
            type: "application/json",
            name: ""
          });
        } else {
          formData.append(
            "metadata[]",
            new Blob([JSON.stringify(value)], { type: "application/json" }),
            ""
          );
        }
      });
    }
    if (body["file[]"] !== void 0) {
      body["file[]"].forEach((value) => {
        formData.append("file[]", value);
      });
    }
    const res = await fetch(url, {
      ...options,
      method: "POST",
      body: formData
    });
    if (res.status >= 300) {
      const responseBody2 = [412].includes(res.status) ? null : await res.text();
      const payload2 = responseBody2 ? JSON.parse(responseBody2) : {};
      throw new FetchError(payload2, res.status, res.headers);
    }
    const responseBody = [204, 205, 304].includes(res.status) ? null : await res.text();
    const payload = responseBody ? JSON.parse(responseBody) : {};
    return {
      body: payload,
      status: res.status,
      headers: res.headers
    };
  };
  const deleteFile = async (id, options) => {
    const url = `${baseURL}/files/${id}`;
    const res = await fetch(url, {
      ...options,
      method: "DELETE",
      headers: {
        ...options?.headers
      }
    });
    if (res.status >= 300) {
      const responseBody = [412].includes(res.status) ? null : await res.text();
      const payload2 = responseBody ? JSON.parse(responseBody) : {};
      throw new FetchError(payload2, res.status, res.headers);
    }
    const payload = void 0;
    return {
      body: payload,
      status: res.status,
      headers: res.headers
    };
  };
  const getFile = async (id, params, options) => {
    const encodedParameters = params && Object.entries(params).flatMap(([key, value]) => {
      const stringValue = Array.isArray(value) ? value.join(",") : typeof value === "object" && value !== null ? JSON.stringify(value) : String(value);
      return [`${key}=${encodeURIComponent(stringValue)}`];
    }).join("&");
    const url = encodedParameters ? `${baseURL}/files/${id}?${encodedParameters}` : `${baseURL}/files/${id}`;
    const res = await fetch(url, {
      ...options,
      method: "GET",
      headers: {
        ...options?.headers
      }
    });
    if (res.status >= 300) {
      const responseBody = [412].includes(res.status) ? null : await res.text();
      const payload2 = responseBody ? JSON.parse(responseBody) : {};
      throw new FetchError(payload2, res.status, res.headers);
    }
    const payload = await res.blob();
    return {
      body: payload,
      status: res.status,
      headers: res.headers
    };
  };
  const getFileMetadataHeaders = async (id, params, options) => {
    const encodedParameters = params && Object.entries(params).flatMap(([key, value]) => {
      const stringValue = Array.isArray(value) ? value.join(",") : typeof value === "object" && value !== null ? JSON.stringify(value) : String(value);
      return [`${key}=${encodeURIComponent(stringValue)}`];
    }).join("&");
    const url = encodedParameters ? `${baseURL}/files/${id}?${encodedParameters}` : `${baseURL}/files/${id}`;
    const res = await fetch(url, {
      ...options,
      method: "HEAD",
      headers: {
        ...options?.headers
      }
    });
    if (res.status >= 300) {
      const responseBody = [412].includes(res.status) ? null : await res.text();
      const payload2 = responseBody ? JSON.parse(responseBody) : {};
      throw new FetchError(payload2, res.status, res.headers);
    }
    const payload = void 0;
    return {
      body: payload,
      status: res.status,
      headers: res.headers
    };
  };
  const replaceFile = async (id, body, options) => {
    const url = `${baseURL}/files/${id}`;
    const formData = new FormData();
    const isReactNative = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    if (body["metadata"] !== void 0) {
      if (isReactNative) {
        formData.append("metadata", {
          string: JSON.stringify(body["metadata"]),
          type: "application/json",
          name: ""
        });
      } else {
        formData.append(
          "metadata",
          new Blob([JSON.stringify(body["metadata"])], {
            type: "application/json"
          }),
          ""
        );
      }
    }
    if (body["file"] !== void 0) {
      formData.append("file", body["file"]);
    }
    const res = await fetch(url, {
      ...options,
      method: "PUT",
      body: formData
    });
    if (res.status >= 300) {
      const responseBody2 = [412].includes(res.status) ? null : await res.text();
      const payload2 = responseBody2 ? JSON.parse(responseBody2) : {};
      throw new FetchError(payload2, res.status, res.headers);
    }
    const responseBody = [204, 205, 304].includes(res.status) ? null : await res.text();
    const payload = responseBody ? JSON.parse(responseBody) : {};
    return {
      body: payload,
      status: res.status,
      headers: res.headers
    };
  };
  const getFilePresignedURL = async (id, options) => {
    const url = `${baseURL}/files/${id}/presignedurl`;
    const res = await fetch(url, {
      ...options,
      method: "GET",
      headers: {
        ...options?.headers
      }
    });
    if (res.status >= 300) {
      const responseBody2 = [412].includes(res.status) ? null : await res.text();
      const payload2 = responseBody2 ? JSON.parse(responseBody2) : {};
      throw new FetchError(payload2, res.status, res.headers);
    }
    const responseBody = [204, 205, 304].includes(res.status) ? null : await res.text();
    const payload = responseBody ? JSON.parse(responseBody) : {};
    return {
      body: payload,
      status: res.status,
      headers: res.headers
    };
  };
  const deleteBrokenMetadata = async (options) => {
    const url = `${baseURL}/ops/delete-broken-metadata`;
    const res = await fetch(url, {
      ...options,
      method: "POST",
      headers: {
        ...options?.headers
      }
    });
    if (res.status >= 300) {
      const responseBody2 = [412].includes(res.status) ? null : await res.text();
      const payload2 = responseBody2 ? JSON.parse(responseBody2) : {};
      throw new FetchError(payload2, res.status, res.headers);
    }
    const responseBody = [204, 205, 304].includes(res.status) ? null : await res.text();
    const payload = responseBody ? JSON.parse(responseBody) : {};
    return {
      body: payload,
      status: res.status,
      headers: res.headers
    };
  };
  const deleteOrphanedFiles = async (options) => {
    const url = `${baseURL}/ops/delete-orphans`;
    const res = await fetch(url, {
      ...options,
      method: "POST",
      headers: {
        ...options?.headers
      }
    });
    if (res.status >= 300) {
      const responseBody2 = [412].includes(res.status) ? null : await res.text();
      const payload2 = responseBody2 ? JSON.parse(responseBody2) : {};
      throw new FetchError(payload2, res.status, res.headers);
    }
    const responseBody = [204, 205, 304].includes(res.status) ? null : await res.text();
    const payload = responseBody ? JSON.parse(responseBody) : {};
    return {
      body: payload,
      status: res.status,
      headers: res.headers
    };
  };
  const listBrokenMetadata = async (options) => {
    const url = `${baseURL}/ops/list-broken-metadata`;
    const res = await fetch(url, {
      ...options,
      method: "POST",
      headers: {
        ...options?.headers
      }
    });
    if (res.status >= 300) {
      const responseBody2 = [412].includes(res.status) ? null : await res.text();
      const payload2 = responseBody2 ? JSON.parse(responseBody2) : {};
      throw new FetchError(payload2, res.status, res.headers);
    }
    const responseBody = [204, 205, 304].includes(res.status) ? null : await res.text();
    const payload = responseBody ? JSON.parse(responseBody) : {};
    return {
      body: payload,
      status: res.status,
      headers: res.headers
    };
  };
  const listFilesNotUploaded = async (options) => {
    const url = `${baseURL}/ops/list-not-uploaded`;
    const res = await fetch(url, {
      ...options,
      method: "POST",
      headers: {
        ...options?.headers
      }
    });
    if (res.status >= 300) {
      const responseBody2 = [412].includes(res.status) ? null : await res.text();
      const payload2 = responseBody2 ? JSON.parse(responseBody2) : {};
      throw new FetchError(payload2, res.status, res.headers);
    }
    const responseBody = [204, 205, 304].includes(res.status) ? null : await res.text();
    const payload = responseBody ? JSON.parse(responseBody) : {};
    return {
      body: payload,
      status: res.status,
      headers: res.headers
    };
  };
  const listOrphanedFiles = async (options) => {
    const url = `${baseURL}/ops/list-orphans`;
    const res = await fetch(url, {
      ...options,
      method: "POST",
      headers: {
        ...options?.headers
      }
    });
    if (res.status >= 300) {
      const responseBody2 = [412].includes(res.status) ? null : await res.text();
      const payload2 = responseBody2 ? JSON.parse(responseBody2) : {};
      throw new FetchError(payload2, res.status, res.headers);
    }
    const responseBody = [204, 205, 304].includes(res.status) ? null : await res.text();
    const payload = responseBody ? JSON.parse(responseBody) : {};
    return {
      body: payload,
      status: res.status,
      headers: res.headers
    };
  };
  const getVersion = async (options) => {
    const url = `${baseURL}/version`;
    const res = await fetch(url, {
      ...options,
      method: "GET",
      headers: {
        ...options?.headers
      }
    });
    if (res.status >= 300) {
      const responseBody2 = [412].includes(res.status) ? null : await res.text();
      const payload2 = responseBody2 ? JSON.parse(responseBody2) : {};
      throw new FetchError(payload2, res.status, res.headers);
    }
    const responseBody = [204, 205, 304].includes(res.status) ? null : await res.text();
    const payload = responseBody ? JSON.parse(responseBody) : {};
    return {
      body: payload,
      status: res.status,
      headers: res.headers
    };
  };
  return {
    baseURL,
    pushChainFunction,
    uploadFiles,
    deleteFile,
    getFile,
    getFileMetadataHeaders,
    replaceFile,
    getFilePresignedURL,
    deleteBrokenMetadata,
    deleteOrphanedFiles,
    listBrokenMetadata,
    listFilesNotUploaded,
    listOrphanedFiles,
    getVersion
  };
};
export {
  createAPIClient
};
//# sourceMappingURL=storage.js.map
