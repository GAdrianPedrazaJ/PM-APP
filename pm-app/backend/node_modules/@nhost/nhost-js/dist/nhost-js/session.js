import { r } from "../refreshSession-WwGlzgtM.js";
const decodeUserSession = (accessToken) => {
  const s = accessToken.split(".");
  if (s.length !== 3 || !s[1]) {
    throw new Error("Invalid access token format");
  }
  const decodedToken = JSON.parse(
    typeof atob !== "undefined" ? atob(s[1]) : Buffer.from(s[1], "base64").toString("utf-8")
  );
  const iat = typeof decodedToken["iat"] === "number" ? decodedToken["iat"] * 1e3 : void 0;
  const exp = typeof decodedToken["exp"] === "number" ? decodedToken["exp"] * 1e3 : void 0;
  const hasuraClaims = decodedToken["https://hasura.io/jwt/claims"];
  const processedClaims = hasuraClaims ? Object.entries(hasuraClaims).reduce(
    (acc, [key, value]) => {
      if (typeof value === "string" && isPostgresArray(value)) {
        acc[key] = parsePostgresArray(value);
      } else {
        acc[key] = value;
      }
      return acc;
    },
    {}
  ) : void 0;
  return {
    ...decodedToken,
    iat,
    exp,
    "https://hasura.io/jwt/claims": processedClaims
  };
};
const isPostgresArray = (value) => {
  return value.startsWith("{") && value.endsWith("}");
};
const parsePostgresArray = (value) => {
  if (!value || value === "{}") return [];
  return value.slice(1, -1).split(",").map((item) => item.trim().replace(/^"(.*)"$/, "$1"));
};
const DEFAULT_SESSION_KEY = "nhostSession";
class LocalStorage {
  storageKey;
  /**
   * Creates a new LocalStorage instance
   * @param options - Configuration options
   * @param options.storageKey - The key to use in localStorage (defaults to "nhostSession")
   */
  constructor(options) {
    this.storageKey = options?.storageKey || DEFAULT_SESSION_KEY;
  }
  /**
   * Gets the session from localStorage
   * @returns The stored session or null if not found
   */
  get() {
    try {
      const value = window.localStorage.getItem(this.storageKey);
      return value ? JSON.parse(value) : null;
    } catch {
      this.remove();
      return null;
    }
  }
  /**
   * Sets the session in localStorage
   * @param value - The session to store
   */
  set(value) {
    window.localStorage.setItem(this.storageKey, JSON.stringify(value));
  }
  /**
   * Removes the session from localStorage
   */
  remove() {
    window.localStorage.removeItem(this.storageKey);
  }
}
class MemoryStorage {
  session = null;
  /**
   * Gets the session from memory
   * @returns The stored session or null if not set
   */
  get() {
    return this.session;
  }
  /**
   * Sets the session in memory
   * @param value - The session to store
   */
  set(value) {
    this.session = value;
  }
  /**
   * Clears the session from memory
   */
  remove() {
    this.session = null;
  }
}
class CookieStorage {
  cookieName;
  expirationDays;
  secure;
  sameSite;
  /**
   * Creates a new CookieStorage instance
   * @param options - Configuration options
   * @param options.cookieName - Name of the cookie to use (defaults to "nhostSession")
   * @param options.expirationDays - Number of days until the cookie expires (defaults to 30)
   * @param options.secure - Whether to set the Secure flag on the cookie (defaults to true)
   * @param options.sameSite - SameSite policy for the cookie (defaults to "lax")
   */
  constructor(options) {
    this.cookieName = options?.cookieName || DEFAULT_SESSION_KEY;
    this.expirationDays = options?.expirationDays ?? 30;
    this.secure = options?.secure ?? true;
    this.sameSite = options?.sameSite || "lax";
  }
  /**
   * Gets the session from cookies
   * @returns The stored session or null if not found
   */
  get() {
    const cookies = document.cookie.split(";");
    for (const cookie of cookies) {
      const [name, value] = cookie.trim().split("=");
      if (name === this.cookieName) {
        try {
          return JSON.parse(decodeURIComponent(value || ""));
        } catch {
          this.remove();
          return null;
        }
      }
    }
    return null;
  }
  /**
   * Sets the session in a cookie
   * @param value - The session to store
   */
  set(value) {
    const expires = /* @__PURE__ */ new Date();
    expires.setTime(
      expires.getTime() + this.expirationDays * 24 * 60 * 60 * 1e3
    );
    const cookieValue = encodeURIComponent(JSON.stringify(value));
    const cookieString = `${this.cookieName}=${cookieValue}; expires=${expires.toUTCString()}; path=/; ${this.secure ? "secure; " : ""}SameSite=${this.sameSite}`;
    document.cookie = cookieString;
  }
  /**
   * Removes the session cookie
   */
  remove() {
    document.cookie = `${this.cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/; ${this.secure ? "secure; " : ""}SameSite=${this.sameSite}`;
  }
}
class SessionStorage {
  storage;
  subscribers = /* @__PURE__ */ new Set();
  /**
   * Creates a new SessionStorage instance
   * @param storage - The underlying storage implementation to use
   */
  constructor(storage) {
    this.storage = storage;
  }
  /**
   * Gets the session from the underlying storage
   * @returns The stored session or null if not found
   */
  get() {
    return this.storage.get();
  }
  /**
   * Sets the session in the underlying storage and notifies subscribers
   * @param value - The session to store
   */
  set(value) {
    const decodedToken = decodeUserSession(value.accessToken);
    const decodedSession = {
      ...value,
      decodedToken
    };
    this.storage.set(decodedSession);
    this.notifySubscribers(decodedSession);
  }
  /**
   * Removes the session from the underlying storage and notifies subscribers
   */
  remove() {
    this.storage.remove();
    this.notifySubscribers(null);
  }
  /**
   * Subscribe to session changes
   * @param callback - Function that will be called when the session changes
   * @returns An unsubscribe function to remove this subscription
   */
  onChange(callback) {
    this.subscribers.add(callback);
    return () => {
      this.subscribers.delete(callback);
    };
  }
  /**
   * Notify all subscribers of a session change
   * @param session - The new session value or null if removed
   */
  notifySubscribers(session) {
    for (const subscriber of this.subscribers) {
      try {
        subscriber(session);
      } catch (error) {
        console.error("Error notifying subscriber:", error);
      }
    }
  }
}
const detectStorage = () => {
  if (typeof window !== "undefined") {
    return new LocalStorage();
  }
  return new MemoryStorage();
};
export {
  CookieStorage,
  DEFAULT_SESSION_KEY,
  LocalStorage,
  MemoryStorage,
  SessionStorage,
  detectStorage,
  r as refreshSession
};
//# sourceMappingURL=session.js.map
