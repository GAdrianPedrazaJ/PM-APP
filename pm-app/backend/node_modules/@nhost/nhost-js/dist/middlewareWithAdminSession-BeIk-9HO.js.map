{"version":3,"file":"middlewareWithAdminSession-BeIk-9HO.js","sources":["../src/fetch/middlewareAttachAccessToken.ts","../src/fetch/middlewareSessionRefresh.ts","../src/fetch/middlewareUpdateSessionFromResponse.ts","../src/fetch/middlewareWithAdminSession.ts"],"sourcesContent":["/**\n * Authorization token attachment middleware for the Nhost SDK.\n *\n * This module provides middleware functionality to automatically attach\n * authorization tokens to outgoing API requests, ensuring the client\n * is properly authenticated.\n */\n\nimport type { Session } from '../auth';\nimport type { SessionStorage } from '../session/storage';\nimport type { ChainFunction, FetchFunction } from './fetch';\n\n/**\n * Creates a fetch middleware that adds the Authorization header with the current access token.\n *\n * This middleware:\n * 1. Gets the current session from storage\n * 2. Adds the authorization header with the access token to outgoing requests\n *\n * This middleware should be used after the refresh middleware in the chain to\n * ensure the most recent token is used.\n *\n * @param storage - Storage implementation for retrieving session data\n * @returns A middleware function that adds Authorization headers\n */\nexport const attachAccessTokenMiddleware =\n  (storage: SessionStorage): ChainFunction =>\n  (next: FetchFunction): FetchFunction =>\n  async (url: string, options: RequestInit = {}): Promise<Response> => {\n    const headers = new Headers(options.headers || {});\n\n    // Skip if Authorization header is already set\n    if (headers.has('Authorization')) {\n      return next(url, options);\n    }\n\n    // Get current session from storage\n    const session = storage.get();\n\n    if (session?.accessToken) {\n      // Add authorization header\n      const newOptions = {\n        ...options,\n        headers: addAuthorizationHeader(headers, session),\n      };\n\n      // Continue with the fetch chain\n      return next(url, newOptions);\n    }\n\n    // No session or no access token, continue without authorization\n    return next(url, options);\n  };\n\n/**\n * Adds the Authorization header with the access token to the request headers\n *\n * @param headers - Original request headers\n * @param session - Current session containing the access token\n * @returns Modified headers with Authorization header\n */\nfunction addAuthorizationHeader(headers: Headers, session: Session): Headers {\n  if (session.accessToken) {\n    headers.set('Authorization', `Bearer ${session.accessToken}`);\n  }\n  return headers;\n}\n","/**\n * Auth token refresh middleware for the Nhost SDK.\n *\n * This module provides middleware functionality to automatically refresh\n * authentication tokens before they expire, ensuring seamless API access\n * without requiring manual token refresh by the application.\n */\n\nimport type { Client } from '../auth';\nimport { refreshSession } from '../session/refreshSession';\nimport type { SessionStorage } from '../session/storage';\nimport type { ChainFunction, FetchFunction } from './fetch';\n\n/**\n * Creates a fetch middleware that automatically refreshes authentication tokens.\n *\n * This middleware:\n * 1. Checks if the current token is about to expire\n * 2. If so, uses the refresh token to obtain a new access token\n *\n * The middleware handles token refresh transparently, so the application\n * doesn't need to manually refresh tokens.\n *\n * @param auth - Auth API client for token refresh operations\n * @param storage - Storage implementation for persisting session data\n * @param options - Configuration options for token refresh behavior\n * @param options.marginSeconds - Number of seconds before token expiration to trigger a refresh, default is 60 seconds\n * @returns A middleware function that can be used in the fetch chain\n */\nexport const sessionRefreshMiddleware = (\n  auth: Client,\n  storage: SessionStorage,\n  options?: {\n    marginSeconds?: number;\n  },\n): ChainFunction => {\n  const { marginSeconds = 60 } = options || {};\n\n  // Create and return the chain function\n  return (next: FetchFunction): FetchFunction =>\n    async (url: string, options: RequestInit = {}): Promise<Response> => {\n      // Skip token handling for certain requests\n      if (shouldSkipTokenHandling(url, options)) {\n        return next(url, options);\n      }\n\n      try {\n        await refreshSession(auth, storage, marginSeconds);\n      } catch {\n        // do nothing, we still want to call the next function\n      }\n      return next(url, options);\n    };\n};\n\n/**\n * Determines if token handling should be skipped for this request\n *\n * @param url - Request URL\n * @param options - Request options\n * @returns True if token handling should be skipped, false otherwise\n */\nfunction shouldSkipTokenHandling(url: string, options: RequestInit): boolean {\n  const headers = new Headers(options.headers || {});\n\n  // If Authorization header is explicitly set, skip token handling\n  if (headers.has('Authorization')) {\n    return true;\n  }\n\n  // If calling the token endpoint, skip to avoid infinite loops\n  if (url.endsWith('/v1/token')) {\n    return true;\n  }\n\n  return false;\n}\n","/**\n * Session response middleware for the Nhost SDK.\n *\n * This module provides middleware functionality to automatically extract\n * and persist session information from authentication responses, ensuring\n * that new sessions are properly stored after sign-in operations.\n */\n\nimport type { Session, SessionPayload } from '../auth';\nimport type { SessionStorage } from '../session/storage';\nimport type { ChainFunction } from './fetch';\n\n/**\n * Creates a fetch middleware that automatically extracts and stores session data from API responses.\n *\n * This middleware:\n * 1. Monitors responses from authentication-related endpoints\n * 2. Extracts session information when present\n * 3. Stores the session in the provided storage implementation\n * 4. Handles session removal on sign-out\n *\n * This ensures that session data is always up-to-date in storage after operations\n * that create or invalidate sessions.\n *\n * @param storage - Storage implementation for persisting session data\n * @returns A middleware function that can be used in the fetch chain\n */\nexport const updateSessionFromResponseMiddleware = (\n  storage: SessionStorage,\n): ChainFunction => {\n  /**\n   * Helper function to extract session data from various response formats\n   *\n   * @param body - Response data to extract session from\n   * @returns Session object if found, null otherwise\n   */\n  const sessionExtractor = (\n    body: Session | SessionPayload | string,\n  ): Session | null => {\n    if (typeof body === 'string') {\n      return null;\n    }\n\n    if ('session' in body) {\n      // SessionPayload\n      return body.session || null;\n    }\n\n    if ('accessToken' in body && 'refreshToken' in body && 'user' in body) {\n      // Session\n      return body;\n    }\n\n    return null;\n  };\n\n  return (next: (url: string, options?: RequestInit) => Promise<Response>) =>\n    async (url: string, options?: RequestInit) => {\n      // Call the next middleware in the chain\n      const response = await next(url, options);\n\n      try {\n        // Check if this is a logout request\n        if (url.endsWith('/signout')) {\n          // Remove session on sign-out\n          storage.remove();\n          return response;\n        }\n\n        // Check if this is an auth-related endpoint that might return session data\n        if (\n          url.endsWith('/token') ||\n          url.includes('/signin/') ||\n          url.includes('/signup/')\n        ) {\n          // Clone the response to avoid consuming it\n          const clonedResponse = response.clone();\n\n          // Parse the JSON data\n          const body = (await clonedResponse.json().catch(() => null)) as\n            | Session\n            | SessionPayload;\n\n          if (body) {\n            // Extract session data from response using provided extractor\n            const session = sessionExtractor(body);\n\n            // If session data is found, store it\n            if (session?.accessToken && session.refreshToken) {\n              storage.set(session);\n            }\n          }\n        }\n      } catch (error) {\n        console.warn('Error in session response middleware:', error);\n      }\n\n      // Return the original response\n      return response;\n    };\n};\n","/**\n * Admin session middleware for the Nhost SDK.\n *\n * This module provides middleware functionality to automatically attach\n * Hasura admin secret for admin permissions in requests.\n */\n\nimport type { ChainFunction, FetchFunction } from './fetch';\n\n/**\n * Configuration options for admin session middleware\n */\nexport interface AdminSessionOptions {\n  /**\n   * Hasura admin secret for elevated permissions (sets x-hasura-admin-secret header)\n   */\n  adminSecret: string;\n\n  /**\n   * Hasura role to use for the request (sets x-hasura-role header)\n   */\n  role?: string;\n\n  /**\n   * Additional Hasura session variables to attach to requests.\n   * Keys will be automatically prefixed with 'x-hasura-' if not already present.\n   *\n   * @example\n   * ```ts\n   * {\n   *   'user-id': '123',\n   *   'org-id': '456'\n   * }\n   * // Results in headers:\n   * // x-hasura-user-id: 123\n   * // x-hasura-org-id: 456\n   * ```\n   */\n  sessionVariables?: Record<string, string>;\n}\n\n/**\n * Creates a fetch middleware that attaches the Hasura admin secret and optional session variables to requests.\n *\n * This middleware:\n * 1. Sets the x-hasura-admin-secret header, which grants full admin access to Hasura\n * 2. Optionally sets the x-hasura-role header if a role is provided\n * 3. Optionally sets additional x-hasura-* headers for custom session variables\n *\n * **Security Warning**: Never use this middleware in client-side code or expose\n * the admin secret to end users. Admin secrets grant unrestricted access to your\n * entire database. This should only be used in trusted server-side environments.\n *\n * The middleware preserves request-specific headers when they conflict with the\n * admin session configuration.\n *\n * @param options - Admin session options including admin secret, role, and session variables\n * @returns A middleware function that can be used in the fetch chain\n *\n * @example\n * ```ts\n * // Create middleware with admin secret only\n * const adminMiddleware = withAdminSessionMiddleware({\n *   adminSecret: process.env.NHOST_ADMIN_SECRET\n * });\n *\n * // Create middleware with admin secret and role\n * const adminUserMiddleware = withAdminSessionMiddleware({\n *   adminSecret: process.env.NHOST_ADMIN_SECRET,\n *   role: 'user'\n * });\n *\n * // Create middleware with admin secret, role, and custom session variables\n * const fullMiddleware = withAdminSessionMiddleware({\n *   adminSecret: process.env.NHOST_ADMIN_SECRET,\n *   role: 'user',\n *   sessionVariables: {\n *     'user-id': '123',\n *     'org-id': '456'\n *   }\n * });\n *\n * // Use with createCustomClient for an admin client\n * const adminClient = createCustomClient({\n *   subdomain: 'myproject',\n *   region: 'eu-central-1',\n *   chainFunctions: [adminMiddleware]\n * });\n * ```\n */\nexport const withAdminSessionMiddleware =\n  (options: AdminSessionOptions): ChainFunction =>\n  (next: FetchFunction): FetchFunction =>\n  async (url: string, requestOptions: RequestInit = {}): Promise<Response> => {\n    const headers = new Headers(requestOptions.headers || {});\n\n    // Set x-hasura-admin-secret if not already present\n    if (!headers.has('x-hasura-admin-secret')) {\n      headers.set('x-hasura-admin-secret', options.adminSecret);\n    }\n\n    // Set x-hasura-role if provided and not already present\n    if (options.role && !headers.has('x-hasura-role')) {\n      headers.set('x-hasura-role', options.role);\n    }\n\n    // Set custom session variables\n    if (options.sessionVariables) {\n      for (const [key, value] of Object.entries(options.sessionVariables)) {\n        // Ensure the key has the x-hasura- prefix\n        const headerKey = key.startsWith('x-hasura-') ? key : `x-hasura-${key}`;\n\n        // Only set if not already present in the request\n        if (!headers.has(headerKey)) {\n          headers.set(headerKey, value);\n        }\n      }\n    }\n\n    return next(url, { ...requestOptions, headers });\n  };\n"],"names":["options"],"mappings":"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"}